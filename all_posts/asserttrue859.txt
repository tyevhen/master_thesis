after listening to the excellent presentation by hans boehm on finalization , threads , and the java technology based memory model , i have come to the conclusion that finalization is one of java 's worst features , if not the worst be clear , i am not talking about the final keyword which is actually a great feature of the language rather , i am talking about the notion of finalizers , or special cleanup methods that the jvm will call before an object is finally reclaimed by the garbage collector the idea is that if you have an object that 's holding onto some system resource such as a file descriptor , you can free that resource in the finalize method right before your no longer used object gets garbage collected the only problem is , there is not only no guarantee as to how quickly , or in what order , your finalizers will be called , there 's also no guarantee that they will be called at all sun 's tony printezis gives a good explanation of finalization in an article on the sun developer network site it 's a brilliant article , but i found myself quite nauseated by the time i got to the end of it finalization is just so wrong so wrong the jvm does not guarantee the order in which it will call the finalizers of the objects in the finalization queue , printezis points out and finalizers from all classes application , libraries , and so on are treated equally so an object that is holding on to a lot of memory or a scarce native resource can get stuck in the finalization queue behind objects whose finalizers are making slow progress oh great , that 's just what i need finalizers blocking on other finalizers while my heap fragments it turns out that an instantiation time , an object that contains a finalizer is marked as such and treated differently by the jvm the extra overhead incurs a performance hit if your application creates many short lived objects with finalizers , the hit can be quite substantial hans boehm see link further above did some testing and found a x slowdown of a test app when objects had finalizers , compared to no finalizers with a really fast jvm , namely jrockit , the slowdown was eleven fold the funny thing is , in all the articles and book chapters i 've read about finalization , i have never , not even once , seen a good real world example of a situation requiring the use of a finalizer supposedly , you use a finalizer when you 're holding onto a system resource and need to free it before your object goes out of scope but in reality , it 's almost always the case that system resources that are considered scarce or precious have a dispose or close or other , similar method , for the explicit purpose of freeing the resource if you use the resource 's normal release mechanism , you do n't need a finalizer in fact a finalizer only lets you hold onto a resource longer than you should someone will argue that you do n't always know when or if an object is going out of scope therefore you should put a call to the release method in a finalizer and be assured that the resource will eventually be released okay , sigh that 's fine and dandy as long as you can count on your finalize method being called which you ca n't and as long as your machine does n't starve for file descriptors , sockets , or whatever the precious resource happens to be , before the finalizer is finally called remember , the jvm makes no guarantees about any of this finalization is non deterministic i have to say , though , that the contorted , non real world examples that are always trotted out to justify the existence of the finalizer mechanism in java have always struck me as more than a little malodorous they all have that unmistakeable antipattern smell that gets in your clothing and makes you feel like taking a hot shower when you get home maybe we should just confront the possibility the likelihood that finalization is evil after all , even the people who write long articles about it end up urging you not to use it that 's good enough for me