if you 're like me , you were probably thrilled to see javascript support come bundled into jdk jre but if you 're using that implementation straight out of the box , you can do far better for execution speed the trick ? get the rhino jar js jar directly from mozilla and include it in your classpath do n't use the built in rhino support in jdk jre it 's too slow i first noticed the speed difference between regular rhino and jdk rhino back in february when i was testing a script that manipulates images see my blog post , voronoi tessellation in linear time in one situation , i found that running my script using the jre 's interpreter took two full minutes , whereas the same script finished in six seconds when i used js jar i decided to follow up on this by running a couple of highly unscientific tests in one case , i came up with a script designed to test the interpreter 's speed at handling numeric operations in another case , i wrote a script designed to test string handling and memory management the results were revealing to test numerical efficiency , i implemented one of euler 's remarkable expansion series for calculating pi euler famously found that if you summed the squares of the reciprocals of all positive integers , the result asymptotically approaches pi squared over the javascript implementation looks like this function piterms sum n whileterms sum n n return math sqrt sum i ran a number of trials with each interpreter , using values for terms of , , , , and the graph below shows the results with execution time plotted vertically the scale ranges from zero to milliseconds numerical efficiency test vertical axis represents execution time notice that the jre starts out slower and execution time rises faster than with rhino that is , the red line has a steeper slope incidentally , with a million terms , the function produces a value of for pi not bad off by only a few parts per hundred million but the series does n't converge quickly enough to be of practical use on modern computers the second test is designed to test string handling and memory management in a kludgy combined fashion folks , this is n't meant to be highly scientific it 's all swag the code looks like this function strings iterations str abc a whilea iterations str str whilea str split join this bit of silliness grows a string by concatenating it with itself over and over again , then repeatedly splits the string into an array of characters and rejoins the array to form a string again if you pass in an iterations value of , you 'll make the string double in size times , crashing any known version of rhino with an oome thus , i tested with values of to execution time topped out at millisec for the jre and ms for rhino again notice that the red curve starts out higher and rises at a steeper slope btw , if you want to see the raw data for these graphs , just inspect the urls for the images these are google chart dynamic images and the raw numbers are in the urls i 'll say it once more this is not intended to be a highly scientific set of tests i believe it to be representative of reality , though , and the reality is , bare naked rhino is significantly faster than embedded in the jre rhino you can do whatever you want i 've seen enough data and i 've made my decision bare naked is the way to go