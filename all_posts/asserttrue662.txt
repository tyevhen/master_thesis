the somewhat blurry image on the left was sharpened , to produce the image on the right , using the two dozen or so lines of javascript code shown further below run in conjunction with the imagemunger java app see text for details as with contrast adjustment , sharpening an image can be thought of as an exercise in weak signal amplification generally it means making the differences between neighboring pixels more noticeable you can do this by brute force analysis of pixels , of course , but area operators kernel based convolutions are the clean way to go a convolution kernel is a d matrix of numbers that can be used as coefficients for numerical operations on pixels suppose you have a x kernel that looks like this as you loop over all pixels in the image , you would , for any given pixel , multiply the pixel itself by zero multiply the pixel directly above the given pixel by also multiply by the pixels to the left , right , and below the pixel in question multiply by one the pixels at o'clock , o'clock , o'clock , and o'clock to the pixel in question add all these numeric values together and divide by the kernel size the result is the new pixel value for the given pixel repeat for each pixel in the image in the example just cited , the kernel etc would end up smoothing or blurring the image , because in essence we are replacing a given pixel 's value with a weighted average of surrounding pixel values to sharpen an image , you 'd want to use a kernel that takes the differences of pixels for example this kernel would achieve a differencing between the center pixel and pixels immediately to the north , south , east , and west it would cause a fairly harsh , small radius high frequency sharpening up of image features it turns out , java has good support for kernel based d convolutions of images using java awt image kernel and java awt image convolveop it takes only a few lines of javascript to run a convolution kernel against a jpeg or other image to achieve sharpening of the image see code listing below a few days ago , i posted code for a small java app called imagemunger that opens an image of your choice and runs a script against it you may want to use that app to run the following code kernel , , , , , , , , function normalizekernel ar for var i , n i ar length i n ar i for var i i ar length i ar i n return ar kernel normalizekernel kernel k new java awt image kernel , , kernel convolver new java awt image convolveop k , java awt image convolveop edge no op , null target new java awt image bufferedimage image getwidth , image getheight , image gettype g target creategraphics g drawimage image , null , , g dispose image convolver filter target , image panel updatepanel recall that the imagemunger app i talked about here a few days ago exports a couple of global variables to the javascript context namely , image a handle to the bufferedimage and panel a reference to the jcomponent in which the image is being displayed with the aid of those globals and appropriate calls to jre methods , it 's very easy to run a convolution easy and fast expect to process around a thousand pixels per millisecond future projects programmatically generate and initialize large kernels have a slider based ui that performs interesting initializations of kernel values kernel based sharpening tends to preferentially add high frequencies to an image , which can be problematic in images that have lots of areas of high frequency noise create a smart sharpen algorithm that dynamically tunes the frequency of the sharpening kernel values according to the natural humm the natural frequencies of the area or areas that are being sharpened as a side benefit of the foregoing , create a sharpening algorithm that wo n't sharpen jpeg artifacts