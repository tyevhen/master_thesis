i came up with kind of a neat trick i 'd like to share if you 're an html canvas programmer , listen up you just might get a kick out of this you know how , when you 're loading images in canvas and then fiddling with the pixels using canvas api code , you have to load your scripts and images from the same server ? for security reasons that 's no problem for the hard core geeks among us , of course many web developers keep a local instance of apache or other web server running in the background for just such occasions as an adobe employee , i'm fortunate to be able to run adobe wem , aka day cq , on my machine but overall , it sucks what i 'd like to be able to do is fiddle with any image , taken from any website i choose , any time i want , without having to run a web server on my local machine so , what i 've done is create a chrome extension that comes into action whenever my browser is pointed at any url that ends in png or jpg or jpeg the instant the image in question loads , my extension puts it into a canvas element , re renders it , and exposes its d context for scripts to work against for demo purposes , i 've included some code for making gamma adjustments to the image via canvas api calls which i 'll talk more about later the code for the chrome extension is shown below to use it , do this copy and paste all of the code into a new file call it brightnesstest user js actually , call it whatever you want , but be sure the name ends with user js save the file text only to any convenient folder launch chrome i did all my testing in chrome the extension should be greasemonkey compatible , but i have not tested it in firefox use control o to bring up the file open dialog navigate to the file you just saved open it notice at the very bottom of the chrome window , there 'll be a status warning saying that extensions can harm your loved ones , etc with two buttons , continue and discard click continue in the confirm installation dialog that pops up , click the install button after you do this , the extension is installed and running test the extension by navigating to http goo gl uqpra the penguin image shown in the above screenshots please try a small image like the penguin first , for performance reasons note due to security restrictions , you ca n't load images from disk no file scheme in the url only http and or https are allowed any png or jpg on the web should work when the image loads , you should see a small slider underneath it this is an html input element if you are using an obsolete version of chrome , you might see a text box instead if you move the slider to the right , you 'll in effect do a gamma adjustment on the image , tending to make the image lighter move the slider to the left , and you 'll darken the image no actual image processing takes place until you lift your finger off the mouse the slider just slides around until a mouseup occurs , then the program logic kicks in after the image repaints , you should see a gamma curve appear under the slider , as in the examples above here 's the code for the chrome extension userscript name imagebrightnesstool namespace ktbrightnesstool description canvas image brightness tool include userscript a demo script by kas thomas use as you will , at your own risk the stuff under loadcode will be injected into a script element in the page function loadcode window lut null ken perlin 's bias function window bias function a , b return math powa , math logb math log window createlut function biasvalue create global lookup table for colors lut createbiascolortable biasvalue window createbiascolortable function b var table new array for var i i i table i applybias i , b return table window applybias function colorvalue , b var normalizedcolorvalue colorvalue var biasedvalue bias normalizedcolorvalue , b return math round biasedvalue window transformimage function x , y , w , h var canvasdata offscreencontext getimagedatax , y , w , h var limit w h for i i limit i canvasdata data i lut canvasdata data i context putimagedata canvasdata , x , y get an offscreen drawing context for the image window getoffscreencontext function w , h var offscreencanvas document createelement canvas offscreencanvas width w offscreencanvas height h return offscreencanvas getcontext d window getcharturl function var url http chart apis google com chart ? url chf bg , lg , , efefef , , bbbbbb , chs x url cht lc chco ff chds , chd t url lut join , url chls chm b , efefef , , , return url setupglobals function window canvas document getelementbyid mycanvas window context canvas getcontext d var imagedata context getimagedata , , canvas width , canvas height window offscreencontext getoffscreencontext canvas width , canvas height window offscreencontext putimagedata imagedata , , setupglobals actually call it end loadcode main function main are we really on an image url ? var ext location href split pop if ext match jpg jpeg png null return ditch the original image img document getelementsbytagname img img parentnode removechildimg put scripts into the page scope in a script elem with id mycode we will eval it in an event later var code document createelement script code setattribute id , mycode document body appendchildcode code innerhtml loadcode tostring n set up canvas canvas document createelement canvas canvas setattribute id , mycanvas document body appendchild canvas context canvas getcontext d image new image image onload function canvas width image width canvas height image height context drawimageimage , , , canvas width , canvas height this line must come after , not before , onload ! image src location href createsliderui create the slider ui creategooglechartui create chart ui function creategooglechartui set up iframe for google chart var container document createelement div var iframe document createelement iframe iframe setattribute id , iframe iframe setattribute style , padding left px iframe setattribute frameborder , iframe setattribute border , iframe setattribute width , iframe setattribute height , container appendchildiframe document body appendchildcontainer create the html slider ui function createsliderui var div document body appendchild document createelement div var slider document createelement input slider setattribute type , range slider setattribute min , slider setattribute max , slider setattribute value , slider setattribute step , if code has n't been loaded already , then load it now one time only ! update the slider range indicator create a color lookup table var actioncode if typeof codeloaded 'undefined' codeloaded code document getelementbyid mycode innerhtml evalcode loadcode document getelementbyid range innerhtml stringthis value substring , createlut numberdocument getelementbyid'range' innerhtml slider setattribute onchange , actioncode the following operation is too timeconsuming to attach to the onchange event we attach it to onmouseup instead slider setattribute onmouseup , document getelementbyid'iframe' src getcharturl transformimage , , canvas width , canvas height div appendchild slider div innerhtml ' span id range span ' this code is a little less elegant in chrome than it would have been in firefox which , unlike chrome , supports ex and exposes a usable unsafewindow object the code does , however , illustrate a number of useful techniques to wit how to swap out an img for a canvas image how to draw to an offscreen context how to inject script code into page scope , from extension gmonkey scope how to use the html slider input element how to change the gamma or , colloquially and somewhat incorrectly , brightness of an image 's pixels via a color lookup table how to use ken perlin 's bias function to remap pixel values in the range how to display the resulting gamma curve actually , bias curve in a google chart in real time that 's a fair amount of stuff , actually discussing it could take a long time the code 's not long , though , so you should be able to grok most of it from a quick read through the most important concept here , from an image processing standpoint , is the notion of remapping pixel values using a pre calculated lookup table the naive and very slow approach would simply be to parse pixels and do a separate bias call on each red , green , or blue value in the image but that would mean calling bias hundreds of thousands of times maybe millions of times , in a sizable image instead , we create a table an array of size and remap the values there once , then look up the appropriate substitution value for each color in each pixel , rather than laboriously calling bias on each color in each pixel if this is the first time you 've encountered ken perlin 's bias function , it 's actually a very important class of function to understand fundamentally , it remaps the unit interval that is , real numbers in the range to itself with a bias value of , all real numbers from map to their original values with a bias value less than , the remapping is swayed in the manner shown in the screenshot above , on the right a bias value greater than bends the curve in exactly the opposite direction but in any case , always ends up mapping to zero and always maps to one , no matter what the bias knob is set to the function is , in that sense , nicely normalized bias is technically quite a bit different from a true gamma adjustment gamma curves come from a different formula and they do n't have the desirable property of mapping onto the unit interval or behaving intuitively with respect to the midpoint nevertheless , because gamma is more familiar to graphic artists , i 've abused that word throughout this post , and even in the headline shame on me the performance of the bias code is surprisingly poor in this particular usage as a chrome extension on my dell laptop , i see processing at a rate of just under , pixels per second the same bias lookup code running in a normal web page not a chrome extension that injects it into page scope goes about ten times faster yes , an order of magnitude faster in a native web page , i can link the image transformation call to an onchange handler so that the image even a large one updates continuously , in real time , as you drag the slider that 's how fast the code is in some of my other projects but in this particular context as a chrome extension it seems to be dreadfully slow , so i 've hooked the main processing routine to an onmouseup handler on the slider otherwise the slider sticks anyway , i hope the techniques in this post have whetted your appetite for more html canvas explorations there are some great canvas demos out there , and i 'll be delving into some more canvas scripting techniques in the not so distant future happy pixel poking !