the original image lena , left , and the same image transformed via smart sobel right last time , i talked about how to implement smart blur the latter gets its smartness from the fact that the blur effect is applied preferentially to less noisy parts of the image the same tactic can be used with other filter effects as well take the sobel kernel , for example float kernel , , , , , , , , convolving an image with this kernel tends to produce an image in which edges only have been preserved , in rather harsh fashion , as seen here ordinary sobel transformation produces a rather harsh result this is an effect whose harshness begs to be tamed by the smart approach with a smart sobel filter , we would apply maximum sobel effect to the least noisy parts of the image and no sobel filtering to the busiest parts of the image , and interpolate between the two extremes for other parts of the image that 's easy to do with just some trivial modifications to the smart blur code i gave last time without further ado , here is the code for the smart sobel filter import java awt image kernel import java awt image bufferedimage import java awt image convolveop import java awt graphics public class smartsobelfilter double sensitivity int region size float kernelarray , , , , , , , , kernel kernel new kernel , , kernelarray float normalizekernel float ar int n for int i i ar length i n ar i for int i i ar length i ar i n return ar public double lerp double a , double b , double amt return a amt b a public double getlerpamount double a , double cutoff if a cutoff return return a cutoff public double rmserror int pixels double ave for int i i pixels length i ave pixels i ave pixels length double diff double accumulator for int i i pixels length i diff pixels i ave diff diff accumulator diff double rms accumulator pixels length rms math sqrt rms return rms int getsample bufferedimage image , int x , int y , int size int pixels try bufferedimage subimage image getsubimage x , y , size , size pixels subimage getrgb , , size , size , null , , size catch exception e will arrive here if we requested pixels outside the image bounds return pixels int lerppixel int oldpixel , int newpixel , double amt int oldred oldpixel int newred newpixel int red int lerp doubleoldred , doublenewred , amt int oldgreen oldpixel int newgreen newpixel int green int lerp doubleoldgreen , doublenewgreen , amt int oldblue oldpixel int newblue newpixel int blue int lerp doubleoldblue , doublenewblue , amt return red green blue int blurimage bufferedimage image , int orig , int blur , double sensitivity int newpixel double amt int size region size for int i i orig length i int w image getwidth int pix getsample image , i w , i w , size if pix length continue amt getlerpamount rmserror pix , sensitivity newpixel lerppixel blur i , orig i , amt orig i newpixel return orig public void invert int pixels for int i i pixels length i pixels i pixels i public bufferedimage filter bufferedimage image convolveop convolver new convolveopkernel , convolveop edge no op , null clone image into target bufferedimage target new bufferedimageimage getwidth , image getheight , image gettype graphics g target creategraphics g drawimageimage , , , null g dispose int w target getwidth int h target getheight get source pixels int pixels image getrgb , , w , h , null , , w blur the cloned image target convolver filtertarget , image get the blurred pixels int blurrypixels target getrgb , , w , h , null , , w invert blurrypixels go thru the image and interpolate values pixels blurimageimage , pixels , blurrypixels , sensitivity replace original pixels with new ones image setrgb , , w , h , pixels , , w return image to use the filter , instantiate it and then call the filter method , passing a java awt image bufferedimage the method returns a transformed bufferedimage there are two knobs to tweak sensitivity and region size the former affects how much interpolation happens between native pixels and transformed pixels a larger value means a more extreme sobel effect the latter is the size of the neighboring region that will be analyzed for noisiness as we step through the image pixel by pixel this parameter affects how blocky the final image looks ideas for further development develop a smart sharpen filter combine with a displacement filter for paintbrush effects overlay combine the same image with copies of itself , transformed with various values for sensitivity and region size , to reduce blockiness