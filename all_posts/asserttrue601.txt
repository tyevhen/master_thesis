original image click to enlarge image with smart blur applied notice that outlines are preserved , even where the oranges overlap one of my favorite photoshop effects is smart blur , which provides a seemingly effortless way to smooth out jpeg artifacts , remove blemishes from skin in photographs of people , etc its utility lies in the fact that despite the considerable blurriness it imparts to many regions of an image , it preserves outlines and fine details the more important parts of an image , usually thus it gives the effect of magically blurring only those parts of the image that you want to be blurred the key to how smart blur works is that it preferentially blurs parts of an image that are sparse in detail rich in low frequency information while leaving untouched the parts of the image that are comparatively rich in detail rich in high frequency information abrupt transitions in tone are ignored areas of subtle change are smoothed and thus made even more subtle the algorithm is quite straightforward march through the image pixel by pixel for each pixel , analyze an adjacent region say , the adjoining pixel by pixel square calculate some metric of pixel variance for that region compare the variance to some predetermined threshold value if the variance exceeds the threshold , do nothing if the variance is less than the threshold , apply blurring to the source pixel but vary the amount of blurring according to the variance low variance , more blurring high variance , less blurring in the implementation presented below , i start by cloning the current image and massively blurring the entire cloned image then i march through the pixels of the original image and begin doing the region by region analysis when i need to apply blurring , i derive the new pixel by linear interpolation between original and cloned image pixels so the first thing we need is a routine for linear interpolation between two values and a corresponding routine for linear interpolation between two pixel values linear interpolation is easy public double lerp double a , double b , double amt return a amt b a linear interpolation between pixels is tedious looking but straightforward int lerppixel int oldpixel , int newpixel , double amt int oldred oldpixel int newred newpixel int red int lerp doubleoldred , doublenewred , amt int oldgreen oldpixel int newgreen newpixel int green int lerp doubleoldgreen , doublenewgreen , amt int oldblue oldpixel int newblue newpixel int blue int lerp doubleoldblue , doublenewblue , amt return red green blue another essential routine that we need is a routine for analyzing the pixel variance in a region for this , i use a root mean square error public double rmserror int pixels double ave for int i i pixels length i ave pixels i ave pixels length double diff double accumulator for int i i pixels length i diff pixels i ave diff diff accumulator diff double rms accumulator pixels length rms math sqrt rms return rms before we transform the image , we should have code that opens an image and displays it in a jframe the following code does that it takes the image whose path is supplied in a command line argument , opens it , and displays it in a jcomponent inside a jframe import java awt graphics import java awt image bufferedimage import java io file import javax imageio imageio import javax swing jcomponent import javax swing jframe public class imagewindow this inner class is our canvas we draw the image on it class imagepanel extends jcomponent bufferedimage theimage null imagepanel bufferedimage image super theimage image public bufferedimage getimage return theimage public void setimage bufferedimage image theimage image this updatepanel public void updatepanel invalidate getparent dolayout repaint public void paintcomponent graphics g int w theimage getwidth int h theimage getheight g drawimage theimage , , , w , h , this end imagepanel inner class constructor public imagewindow string args open image bufferedimage image openimagefile args create a panel for it imagepanel theimagepanel new imagepanel image display the panel in a jframe createwindowforpanel theimagepanel , args filter the image filterimage theimagepanel public void filterimage imagepanel panel smartblurfilter filter new smartblurfilter bufferedimage newimage filter filter panel getimage panel setimage newimage public void createwindowforpanel imagepanel theimagepanel , string name bufferedimage image theimagepanel getimage jframe mainframe new jframe mainframe settitle name mainframe setbounds , , image getwidth , image getheight mainframe setdefaultcloseoperation mainframe getcontentpane add theimagepanel mainframe setvisibletrue bufferedimage openimagefile string fname bufferedimage img null try file f new file fname if f exists img imageio readf catch exception e e printstacktrace return img public static void main string args new imagewindow args note the method filterimage , where we instantiate a smartblurfilter without further ado , here 's the full code for smartblurfilter import java awt image kernel import java awt image bufferedimage import java awt image convolveop import java awt graphics public class smartblurfilter double sensitivity int region size float kernelarray , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , kernel kernel new kernel , , normalizekernel kernelarray float normalizekernel float ar int n for int i i ar length i n ar i for int i i ar length i ar i n return ar public double lerp double a , double b , double amt return a amt b a public double getlerpamount double a , double cutoff if a cutoff return return a cutoff public double rmserror int pixels double ave for int i i pixels length i ave pixels i ave pixels length double diff double accumulator for int i i pixels length i diff pixels i ave diff diff accumulator diff double rms accumulator pixels length rms math sqrt rms return rms int getsample bufferedimage image , int x , int y , int size int pixels try bufferedimage subimage image getsubimage x , y , size , size pixels subimage getrgb , , size , size , null , , size catch exception e will arrive here if we requested pixels outside the image bounds return pixels int lerppixel int oldpixel , int newpixel , double amt int oldred oldpixel int newred newpixel int red int lerp doubleoldred , doublenewred , amt int oldgreen oldpixel int newgreen newpixel int green int lerp doubleoldgreen , doublenewgreen , amt int oldblue oldpixel int newblue newpixel int blue int lerp doubleoldblue , doublenewblue , amt return red green blue int blurimage bufferedimage image , int orig , int blur , double sensitivity int newpixel double amt int size region size for int i i orig length i int w image getwidth int pix getsample image , i w , i w , size if pix length continue amt getlerpamount rmserror pix , sensitivity newpixel lerppixel blur i , orig i , amt orig i newpixel return orig public bufferedimage filter bufferedimage image convolveop convolver new convolveopkernel , convolveop edge no op , null clone image into target bufferedimage target new bufferedimageimage getwidth , image getheight , image gettype graphics g target creategraphics g drawimageimage , , , null g dispose int w target getwidth int h target getheight get source pixels int pixels image getrgb , , w , h , null , , w blur the cloned image target convolver filtertarget , image get the blurred pixels int blurrypixels target getrgb , , w , h , null , , w go thru the image and interpolate values pixels blurimageimage , pixels , blurrypixels , sensitivity replace original pixels with new ones image setrgb , , w , h , pixels , , w return image despite all the intensive image analysis , the routine is fairly fast on my machine , it takes about one second to process a x image that 's slower than photoshop by a factor of five , or more , but still not bad given that it 's only java ideas for further development substitute a directional blur for the non directional blur substitute a sobel kernel for the blur kernel try other sorts of kernels as well