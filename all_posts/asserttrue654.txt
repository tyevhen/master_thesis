top left the source image x jpeg top right the same image as a collage of voronoi cells lower left cells lower right cells , embossed click any image to see a larger version a voronoi tessellation is a factoring of space into polygonal regions that enclose points one point per region in such a way that the boundary between two adjoining regions runs at a perpendicular to the imaginary line connecting the nearest two points , while also being midway between the two points in the simplest case , a set of points s voronoi sites defines a corresponding number of cells vs , with any given cell consisting of all points closer to s than to any other site the segments of the voronoi diagram are all the points in the plane that are equidistant to the two nearest sites if you look at the points in the diagram below , you can see that an imaginary line connecting any two neighboring points will be bisected at a right angle by a cell boundary and the cell boundary will be exactly midway between the points that 's what makes a voronoi cell a voronoi cell voronoi diagrams are named after russian mathematician georgy fedoseevich voronoi , but their use dates back hundreds of years descartes was already familiar with them in british physician john snow supposedly used a voronoi diagram in to illustrate how the majority of people who died in the soho cholera epidemic lived closer to the infected broad street pump than to any other water pump the dual graph for a voronoi diagram corresponds to the delaunay triangulation for the same set of points delaunay is an interesting construction in its own right , but we 'll save it for another day for now suffice it to say that delaunay offers a way of taking a field of coplanar points and making them into a field of triangles composed in such a way that the circumcircle inscribed by any given triangle encloses no other points voronoi tessellated forms tend to be aesthetically pleasing if the tessellation is done so as to produce more cells in areas high in detail , and fewer cells in low detail areas although not always fast tessellation of a point field into voronoi cells generally takes depending on the algorithm either n squared or n log n time meaning , it can be quite slow if the number of points is large fortunately , we can take advantage of a space filling trick to make the whole process occur in linear time i e , time order n to n , in practice to see how the algorithm works , imagine , if you will , a field of points let each point magically become a soap bubble now grow each bubble slowly when two bubbles meet , their walls fuse together into one flat section that joins the two , with a boundary that 's perpendicular to the imaginary line connecting the centers of the bubbles if you 've seen two bubbles stuck together , you know what i mean there 's a flat side to each bubble where they join together continue to grow all bubbles until there are no more curved edges only flat walls this is the approach we use we take a field of points and dilate them grow them in all directions at once until they become regions that adjoin if all regions grow at the same speed , natural boundaries will form , and those boundaries will define voronoi cells but how to redefine an image as a series of points ? easy just take random samples of the image actually , for the most visually pleasing result , we do n't want random samples we want to take more samples in areas of high detail and fewer samples in areas of gradual color change this is easy enough to do with an algorithm that walks through the image , looking at how much each pixel differs from the pixels around it we accumulate the variance into a running average , and when that number exceeds a certain arbitrary threshold , we take a sample otherwise , set visited pixels to white the javascript below shows how it 's done the loadsamples method walks through the image , taking samples of pixel values more frequent samples in rapidly fluctuating areas , less frequent samples in areas of little variation once a field of samples has been captured , we call the spacefill method , which dilates the points by growing them in north , south , east , and west directions until the image space is filled i do frequent checks to see if we 're done filling in which case we break out of the loop generally , if the average cell size is small enough to give a pleasing visual appearance , the whole image can be filled in iterations or so smaller more numerous cells can be filled quickly , hence fewer iterations with more cells sounds counterintuitive at first note that to run this script , you may want to use the little imagemunger app i gave code for in a previous post imagemunger will open an image and run a script against it along the way , it puts image and panel globals in scope at runtime see previous post for details unaccountably , i found that this code runs much faster using the separate mozilla rhino js jar than using jdk 's onboard script engine when i say much faster , i'm talking the difference between six seconds and two minutes i did n't try to troubleshoot it voronoi js kas thomas february public domain loop over all the pixels in the image and sample them , taking more samples in areas of detail , fewer samples in areas of little variation function loadsamples pixels , rasterwidth , threshold length pixels length accumulatederror thispixel north south east west ave samples new array pixels length for var i i samples length i samples i for var i i length i thispixel getpixelstrength pixels i north i rasterwidth ? getpixelstrength pixels i rasterwidth south i i rasterwidth ? getpixelstrength pixels i rasterwidth east i length ? getpixelstrength pixels i west i ? getpixelstrength pixels i ave north south east west math random accumulatederror ave thispixel if accumulatederror threshold samples i pixels i accumulatederror else samples i xffffff return samples get green value , scale it to function getpixelstrength p value p return value var w image getwidth var h image getheight var pixels image getrgb , , w , h , null , , w sensitivity var newpixels loadsamples pixels , w , sensitivity starting with a field of points , grow the points evenly until their regions touch function spacefill pixels , limit , width var i iterate over all sample points and dilate them for i i limit i var fillcount for var k k pixels length k fillcount fillleft k , pixels if fillcount done filling ? bail break for var k width k pixels length k fillcount fillup k , width , pixels if fillcount break for var k pixels length k k fillcount fillright k , pixels if fillcount break for var k pixels length width k k fillcount filldown k , width , pixels if fillcount break return i dilation functions function fillright i , pixels if pixels i xffffff xffffff pixels i pixels i return return function filllefti , pixels if pixels i xffffff xffffff pixels i pixels i return return function fillupi , width , pixels if pixels i width xffffff xffffff pixels i width pixels i return return function filldowni , width , pixels if pixels i width xffffff xffffff pixels i width pixels i return return this optional function is for reporting purposes only function howmanysamples pixels for var i , n i pixels length i if pixels i ! xffffff n java lang system out println n samples samplecount howmanysamples newpixels var iterations spacefill newpixels , , w java lang system out println image filled in iterations iterations image setrgb , , w , h , newpixels , , w panel updatepanel draw it to get more voronoi cells finer granularity of resolution , decrease the value of the sensitivity constant a value around will yield a point field with a density of around percent in other words , point samples per pixels to get half as many samples , double the sensitivity value