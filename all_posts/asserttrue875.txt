i do n't know why it took me so long to realize that there 's an easy , fast way to obtain the average of two rgb pixel values an rgb pixel is commonly represented as a bit integer let 's assume the top bits are n't used to ensure proper averaging of red , green , and blue components of two pixels requires parsing those bit values out of each pixel and adding them together , then dividing by two , and crafting a new pixel out of the new red , green , and blue values or at least that 's the naive way of doing things in code i 'll show it in javascript , but it looks much the same in c or java the horribly inefficient naive way function average a , b var redmask xff var greenmask xff var bluemask xff var ared a redmask var agreen a greenmask var ablue a bluemask var bred b redmask var bgreen b greenmask var bblue b bluemask var avered ared bred var avegreen agreen bgreen var aveblue ablue bblue return avered avegreen aveblue that 's a lot of code to average two bit values , but remember that red , green , and blue values bits each have to live in their own swim lanes you ca n't allow overflow here 's the much cleaner , less obvious , hugely faster way the fast way maskbits xfefeff function ave a , b a maskbits b maskbits return a b the key intuition here is that you want to clear the bottom bit of the red and green channels in order to make room for overflow from the green and blue adds of course , in the real world , you would inline this code rather than use it as a function in a loop that 's processing x pixels you surely do n't want to call a function hundreds of thousands of times similar mask based techniques can be used for adding and subtracting pixel values overflow is handled differently , though left as an exercise for the reader