good coders code , great ones reuse how can anyone disagree with that ? i do n't disagree the principle of not reinventing something after you 've invented it is so old and so obvious and so obviously useful that no one would seriously dispute it what 's very much worth disputing , though , is the value of code reuse percentage as a metric , and the degree to which code reusability actually brings about any economies in the software business i would argue that the economies are largely nonexistent , because of the generally high cost of achieving reusability in the first place and a failure to depreciate investments in reusability over time if you 're reusing code in your product that was written in to support a file format , say and that code is only still in the product for legacy reasons , should that really count as reuse ? should n't reuse be weighted according to whether the code actually gets executed or not ? should you build out on bad code flabby code spaghetti code stuff that may contain unreachable or deprecated methods , etc and count it as reusability ? or go back and do it right ? if you build out on bad code , you 've achieved reusability if you go back and clean up the code , you 've killed your reuse metrics but you may well score a longterm roi win there are so many problems with reuse percentage as a metric that i wo n't litigate the case fully here but instead ask you to refer to the paper by lim , the blog by dennis forbes , and the blog by carl lewis for starters will tracz an early advocate of reuse , ironically pointed out in software reuse myths revisited that reusable code costs around more to develop than code not designed with reuse in mind that estimate derived in is probably off by a factor of three or four maybe ten , with java but it 's moot , in any case , given that the cost of producing code is , in reality , a comparatively small part of the overall cost of producing and marketing commercial software and that 's what i'm really saying here , is that the potential for cost savings is not a proper motivation for reuse there is no significant cost savings it costs more to develop reusable code , and the payoffs are mitigated by longterm maintenance costs associated with a larger code base someone will inevitably argue that although you may end up with more classes and interfaces if you design for reusability , the code will ultimately be more readable i dispute that the code becomes more complex generally and it 's not necessarily true that it becomes more readable does jmenu really need to have methods ? why ? it got that way because someone lazily decided to use inheritance as a code reuse mechanism , instead of designing jmenu to have just what it needs you could argue , well , so what ? the ancestor classes are already written , they never have to be written again , why not reuse them ? there are so many fallacies with that argument , it 's hard to know where to begin jmenu is at the bottom of a classes deep inheritance chain the odds that nothing in that chain will ever be rewritten in the future are small touching the code in that chain entails risk a breakage risk for subclasses this is the kind of thing that keeps half of bangalore in business , doing regression tests at runtime , you 're carrying around the baggage of odd methods you do n't need the footprint of your software on disk and in memory is bigger , performance is affected , garbage collection is affected what i'm suggesting is not that you should rewrite jmenu what i'm saying is that if you 're sun , and you 're going to write something like swing from a clean sheet of paper , do it with common sense in mind rather than taking an inherit the world approach to reusability rest assured , when i write code , i try out of sheer laziness to make as many lines classes and methods reusable as makes sense and no more and i guess that 's the point sometimes it does n't make sense to go out of your way to write highly reusable code sometimes it 's more important to have something small and streamlined that works now , that 's purpose built and does what it does well if you can do that , fine if you ca n't , for some reason , that 's fine too , but do what 's appropriate to the situation that does not mean you abandon good programming practices it does n't mean you write poorly structured code it means you write only as much code as you need , and resist the temptation to overfactor unfortunately , the latter can be quite hard , especially if you 're steeped in the java arts there 's a place in this world for silverware , and there 's a place for plastic spoons and yes , you can recycle plastic spoons , but for gosh sakes , silverware is expensive let 's not accumulate it needlessly