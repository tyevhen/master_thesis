the image on the left is the x pixel original rgb image the copy on the right has been tiled into solid filled rectangles see text for discussion conversion of bitmapped images jpg , gif , etc to vector format postscript , svg is , in general , a difficult problem in some ways , it 's not unlike trying to convert spoken text in the form of mp audio to ascii well okay , maybe it 's not that bad , but it 's gnarly you 're trying to parse precise geometric shapes out of an ensemble of intensity samples it 's not at all obvious how to do it finding a fully general algorithm for describing an arbitrary bitmap as an ensemble of vector drawable shapes is vexingly difficult you might as well try to reassemble yugoslavia you have to admit , though , it 'd be darned handy to be able to transcode a bitmap image into say some flavor of xml such as svg unlike binary formats , xml is wire protocol friendly , queryable at the element and attribute level , transformable using xslt and or ex , or other technologies , human readable bwahhh ha ha , and highly compressible converting jpeg to xml would open the door potentially to many interesting operations imagine running xpath queries against images to find specific areas of interest , or morphing one image into another using xslt while there is obviously no one right way to proceed , i 'd like to propose an approach to the problem the problem of how to transcode bitmaps to svg based on quadtree decomposition of an image into polygons rectangles , in particular it 's possible to apply the same approach using triangles as primitives , instead of rects , or spline patches for that matter , but rectangles offer some noteworthy advantages most images are rectangles to begin with , of course , and parsing them into smaller but adjoining rects is a natural thing to do once parsed , rects allow a relatively compact representation and at render time , not many solid shapes are easier or faster to draw we have the considerable advantage of being able to start from the perspective of seeing a bitmapped image as just a grid of one by one rectangles known as pixels two adjoining pixels of the same color become a x solid color rect , four adjoining identical pixels become a x or x rect , and so on surely we can parse out the naturally occurring solid filled rects within a pixel lattice ? those rects are instantly vector drawable if we do this , we 'll get what we get probably a very small handful of accidental finds but we can do better , if through preprocessing we quantize pixel values in such a way as to force nearly equal pixels to be equal in value this will cause the appearance of a higher percentage of solid color rects within a bitplane of course , when we 're done , there 's still no guarantee we will have covered the entire visual plane with rects unless , as i say , we count individual pixels as x rects nevertheless , it 's an interesting strategy force adjoining almost equal pixels to be equal in value , then aggregate them into solid color rects deal with the leftovers later at the extreme , we can look at the entire image as being a collection of pixels that are nearly equal in value there is actually considerable variance in pixels , of course unless the image is truly not very interesting but what we might do is quantify the variance in some way , and if it exceeds a threshold , divide the image into daughter rects and begin again we know that eventually , if we keep subdividing , we 'll get to individual pixels x rects that have zero variance within themselves by this sort of strained logic we might convince ourselves that there should be less variance in small rects than in large ones , as a general trend let me get right to it and propose an algorithm listen up start by considering a rectangle covering the whole image going pixel by pixel , calculate some variance measure such as root mean square variation from average for all pixels , for the whole region if the variance is low lower than some arbitrary limit , consider all pixels within the region to be equal define the region as a rect of color argb representing the arithmetic average of the pixel values if the variance exceeds an arbitrary threshold , subdivide the image specifically , subdivide it into four generally unequal rects to determine where to subdivide , calculate the center of gravity of the parent rect a pixel 's lightness or darkness , multiplied by its position vector , gives its moment in x and moment in y add all the x moments together and the y moments divide by the number of pixels the result is the visual center of the region that 's where you divide repeat the procedure on newly created rectangular regions any regions with low variance can be rendered as a solid color rect the other regions are subdivided , and the algorithm continues until reaching individual pixels , or until every region larger than a pixel was successfully encoded as a rect this general technique is known as quadtree subdivision and it lends itself well to recursive implementation you 're not likely to get into stack overflow problems with it , because with four times as many rects at each recursion cycle , you 'll have created potentially over rects in just cycles ten levels deep , you 've created a million rects better start worrying about heap , not stack a demonstration of the technique can be seen below the image on the left was created using a fairly insensitive variance threshold of meaning that subdivision did not occur unless a region had an rms variance of at least , out of a possible range of pixel values of because subdivision happened infrequently , only in the very noisiest of pixel regions , smaller rects tended to cluster in areas of high detail high variation in pixel intensities , such as around the edges of the iris and eyelashes the image on the right shows that with the rms threshold set lower at , we get more detail about rects total white outlines around the rects have been omitted on the right image the image on the left has been parsed into solid rectangles with white outlines for illustrative purposes using the recursive quadtree decomposition described in the text notice how subdivision into smaller rectangles tends to coincide with areas of high detail the image on the right has been parsed into rects the algorithm is tunable in a couple of ways the most obvious way is via the variance cutoff parameter if the variance threshold is set low , it means that the slightest bit of noise in a given region will trigger subdivision of the region and continued operation of the algorithm however , we have to stop subdividing before reaching individual pixels so another tuning variable is the minimum tile size the image on the left is a collage of solid filled rectangles at a rect count of , the image on the right is starting to have a bitmap like feel the code that produced these images consists of lines of javascript shown below and another lines of java utility routines in a class called imageutilities see further below in addition to that , you need the imagemunger java application that i described in yesterday 's post yet another lines or so of java first , the javascript tiles js kas thomas january public domain note for this to work , you need the imagemunger java app at http ly ubp you also need the imageutilities class described at the same blog recursive subdivision function quadrecurse ar , rect if ! isdivisible rect ar push rect return var newrects quaddivide rect partition rect for var i i newrects length i size check if newrects i newrects i ar pushrect return for var i i newrects length i recurse on each new rect quadrecurse ar , newrects i function quaddivide rect var pixarray getpixarrayfromrect rect get the visual center of gravity of the image var cg packages imageutilities getcg pixarray , rect cg cg cg cg cg cg cg cg var centerx cg rect xffff centerx rect var centery cg rect xffff centery rect var widthtocenterx centerx rect var heighttocentery centery rect var rect rect , rect , widthtocenterx , heighttocentery ul var rect rect , centery , widthtocenterx , rect heighttocentery ll var rect rect widthtocenterx , rect , rect widthtocenterx , heighttocentery ur var rect rect widthtocenterx , centery , rect widthtocenterx , rect heighttocentery lr return rect , rect , rect , rect divisibility function isdivisible rect if rect width threshold rect height threshold return false var pixarray getpixarrayfromrect rect var rms packages imageutilities getrmserror pixarray if rms rmserror threshold return false return true function getpixarrayfromrect rect var sub image getsubimage rect , rect , rect , rect return sub getrgb , , rect , rect , null , , rect render function render ar var gd image creategraphics var r null var sub null var pixels null var color null for var i i ar length i r ar i if r continue r if r continue r pixels getpixarrayfromrectr color packages imageutilities getaverageawtcolor pixels gd setpaint color gd fillrect r , r , r , r fill solid if outlines true gd setcolor java awt color white gd drawrect r , r , r , r panel updatepanel write svg function writesvg preamble , destfile , ar var r null var pixels null var awt null var color null var output ' ? xml version encoding utf standalone no ? ' ' n ! doctype svg public wc dtd svg en ' ' http www w org tr rec svg dtd svg dtd ' ' svg xmlns http www w org svg ' 'xmlns xlink http www w org xlink ' 'viewbox ' 'xml space preserve ' 'width px ' 'height px ' output g transform scale for var i , r null i ar length i r ar i pixels getpixarrayfromrectr awt packages imageutilities getaverageawtcolor pixels color awtcolortohex awt output outputsvgrect mainarray i , color output g output n svg write output to file packages imageutilities savestringtofileoutput , destfile function inttohex num num hexstr '' num tostring while hexstr length hexstr hexstr substring return hexstr function awtcolortohex awt var theint awt getred awt getgreen awt getblue return inttohex theint function outputsvgrect r , color var str rect x str r str y r str width r str height r str fill color str stroke color str r return str main work routine usage doquadding , , svg , c test svg writes output to an svg file or doquadding , , preview , null renders image in jframe function doquadding rms , sizelowlimit , mode , dest if image null java lang system out println nothing to do no source image return w image getwidth h image getheight mainrect , , w , h mainarray new array rmserror threshold rms width threshold height threshold sizelowlimit quadrecurse mainarray , mainrect recurse java lang system out println total rects mainarray length if mode tolowercase indexof preview ! java lang system out println rendering render mainarray if mode tolowercase indexof svg ! java lang system out println writing writesvg c temp svgstub txt , dest , mainarray java lang system out println done outlines false var start new date actually call the entry point begin processing doquadding , , preview , null doquadding , , svg , c temp test svg var end new date java lang system out println finished in end start milliseconds to use this file , give it a name like tiles js , then run imagemunger the java app i described in yesterday 's post from the command line , passing it the name of the image you want to modify , and the name of the script file java imagemunger myimage jpg tiles js the entry point for the script is doquadding , which you can call with a rd argument of svg if you want to write output to a scalable vector graphics file otherwise pass a rd arg of preview and imagemunger will simply render the transformed image to a jframe the script makes reference to a number of utility routines written in java the utility routines are in a class called what else ? imageutilities , as follows the routines should be fairly self explanatory import java io bufferedreader import java io file import java io fileoutputstream import java io filereader import java io ioexception import java io outputstream imageutilities java kas thomas january see http ly ubp and subsequent posts public class imageutilities public static void savestringtofile string content , string outpath outputstream out null try out new fileoutputstreamoutpath out writecontent getbytes catch ioexception e system out println could n't save to outpath e printstacktrace finally try if out ! null out close catch ioexception e e printstacktrace get the visual center of gravity of a pixel array pass the array and the raster width public static double getcgint pix , int w double intensity int red int green int blue double cg , double averageintensity int pvalue for int i i pix length i pvalue pix i red pvalue green pvalue blue pvalue intensity doublered blue green averageintensity intensity cg intensity i w cg intensity i w cg averageintensity cg averageintensity cg w cg pix length w return cg public static double getrmserror int pix double accumulator double diff double aveintensity double rms int len pix length for int i i len i aveintensity doublepix i aveintensity len for int i i len i diff doublepix i aveintensity accumulator diff diff rms accumulator len return math sqrtrms public static java awt color getaverageawtcolor int input int ave getaveragecolor input int red ave int green ave int blue ave return new java awt colorred , green , blue public static int getaveragecolor int input int red int green int blue int pvalue int averagered int averagegreen int averageblue int len input length for int i i len i pvalue input i red pvalue green pvalue blue pvalue averagered red averagegreen green averageblue blue averagered len averagegreen len averageblue len return averagered averagegreen averageblue public static double getintensity int pvalue int red pvalue int green pvalue int blue pvalue double intensity red blue green return intensity public static double getintensity java awt color c int intvalue c getred intvalue c getgreen intvalue c getblue return getintensity intvalue public static java awt color getawtcolor int pvalue int red pvalue int green pvalue int blue pvalue return new java awt colorred , green , blue public static double getrmse int pix , int pix double rms double accum double intensity double intensity double tmp if pix length ! pix length system out println arrays are not the same size return rms for int i i pix length i intensity getintensity pix i intensity getintensity pix i tmp intensity intensity tmp tmp accum tmp rms accum pix length the mean of the squares return math sqrt rms root mean square even though the main routine is in javascript , the overall processing runs quickly the algorithm executes in near linear time and can output around rectangles per second to screen , that is disk i o not included projects for the future write gradient filled rects instead of solid filled rects , choosing the gradient endpoint colors in such a way as to minimize the differences between the output and the original image given two svg images , each an ensemble of rects preferably equal in number , write a transformation routine that morphs one image into the other via transformations to the individual rects and their colors store the second image as simply an ensemble of transformations no rects the first image provides the reference rectangles that will be transformed write a public key image encryption routine based on the foregoing notion , such that image a becomes a key that someone can use to encrypt image b , with private key image c unlocking b instead of writing an svg image as an ensemble of individual rects , write it as one rect that is repeatedly resized and repositioned via successive affine transformations encrypt an image using the above technique rewrite one rect many times through transformation in concert with matrix hashing write an svg image encryption routine whose difficulty of decryption depends on the non commutative nature of matrix multiplication and the numerical instability of inverted matrices write a chunky jpeg routine that essentially uses the quadtree decomposition to chunk the image prior to discrete cosine transformation , instead of using the canonical jpeg x chunking insert your own idea here !