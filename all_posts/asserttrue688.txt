i continue to think about garbage collection a lot , not only as a career move but in the context of browser performance , enterprise app scaleup , realtime computing , and virtual machine design certainly we 're all affected by it in terms of browser behavior memory leakage has been an ongoing concern in firefox , for example , and the mozilla team has done a lot of great work to stem the leakage much of that work centers , of course , on improving garbage collection one thing that makes browser memory leak troubleshooting such a thorny issue is that different browser subsystem modules have their own particular issues so for example , the javascript engine will have its own issues , the windowing system will have its issues , and so on what makes the situation even trickier is that third party extensions interact in various ways with the browser and each other and then there are the monster plug ins for acrobat reader , flash , shockwave , java , quicktime , and so on , many of which simply leak memory and blow up on their own , without added help from firefox a lot 's been written about gc in java and java is supposed to be much less leakage prone that java but flash is a bit of a mystery the memory manager was apparently rewritten for flash player , and enhanced again for i do n't know what they did for at a high level , the flash player 's gc is very java like a nondeterministic mark and sweep system what the exact algorithms are , though , i do n't know how they differ for different kinds of flex , flash , air , and or shockwave runtime environments , on different operating systems , i do n't know i do know a couple of quirky things one is that in an air application , the system gc method is only enabled in content running in the air debug launcher adl or in content in the application security sandbox also , as with java , a lot of people wrongly believe that calling system gc is an infallible way to force garbage collection to happen in air , system gc only does a mark or a sweep on any given object , but not both in the same call you might think that this means that if you simply call system gc twice in a row , it 'll force a collection by causing both a mark and a sweep right ? not so fast there are two different kinds of pointers in the vm at runtime those in the bytecode and those in the bowels of the vm which kind did you create ? you 'll only sweep the bytecode ones how the details of memory management differ in air , flash , and flex is a bit of a mystery to me but they do differ the flex framework apparently makes different assumptions about garbage lifecycles vis vis a pure flash app the use cases for flex versus flash are , of course , quite different and have no doubt influenced the gc approach flash comes from a tradition of short lived sprite based apps that the user looks at briefly , then dismisses obviously you can use a very tactical approach to gc in that specific case but if you 've got an app flex based that is long running and not constantly slamming animation frames to the video buffer , you need a more strategic approach to gc when i say you , i'm talking about the folks who are tasked with designing the adobe vm 's memory management logic , not the application developer a flex based dam or cms client made for enterprise customers wo n't necessarily benefit from a memory management system designed for sprite animations in a sidebar ad by now every developer who cares about memleaks in as knows not to use anonymous functions inside event handlers callbacks should have a name so they can be gc 'd and weak references should be used however , weak references wo n't totally save the day here in as , asynchronous objects register themselves with the flash player when they run if one of those objects timer , loader , file , db transaction continues to be referenced by the player , it 's essentially unreachable to you there 's also the issue of object memory versus rendering memory the bulk of all memory used by the flash player goes toward rendering and that 's the part you have the least control over a stage in flash can grow to mb fairly easily , but if you try to destroy it you might only reclaim mb i have no idea how much of this can be attributed to as c object entanglement versus deep vm mayhem or some other gnarly issue overall , i think gc is regardless of technology something that benefits from openness and community involvement in other words , this is an area where proprietary serves no one the code needs to be open source and the community needs to be involved in figuring out solutions to deep memory management issues apps ca n't simply be allowed to detonate unpredictably , for no apparent reason or no easily troubleshot reason , in a web world , or in enterprise bottom line ? solving memory management problems at the framework and vm level is critical to the future success of something like air or flex it 's much too important to be left to an adobe