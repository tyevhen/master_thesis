image left pixel original rgb image copy right tiled solid filled rectangles see text discussion conversion bitmapped images jpg gif etc vector format postscript svg general difficult problem ways unlike trying convert spoken text form mp audio ascii well okay maybe bad gnarly trying parse precise geometric shapes ensemble intensity samples obvious finding fully general algorithm describing arbitrary bitmap ensemble vector drawable shapes vexingly difficult might well try reassemble yugoslavia admit though darned handy able transcode bitmap image say flavor xml svg unlike binary formats xml wire protocol friendly queryable element attribute level transformable using xslt ex technologies human readable bwahhh ha ha highly compressible converting jpeg xml would open door potentially many interesting operations imagine running xpath queries images find specific areas interest morphing one image another using xslt obviously one right way proceed i like propose approach problem problem transcode bitmaps svg based quadtree decomposition image polygons rectangles particular possible apply approach using triangles primitives instead rects spline patches matter rectangles offer noteworthy advantages images rectangles begin course parsing smaller adjoining rects natural thing parsed rects allow relatively compact representation render time many solid shapes easier faster draw considerable advantage able start perspective seeing bitmapped image grid one one rectangles known pixels two adjoining pixels color become solid color rect four adjoining identical pixels become rect surely parse naturally occurring solid filled rects within pixel lattice rects instantly vector drawable get get probably small handful accidental finds better preprocessing quantize pixel values way force nearly equal pixels equal value cause appearance higher percentage solid color rects within bitplane course done still guarantee covered entire visual plane rects unless i say count individual pixels rects nevertheless interesting strategy force adjoining almost equal pixels equal value aggregate solid color rects deal leftovers later extreme look entire image collection pixels nearly equal value actually considerable variance pixels course unless image truly interesting might quantify variance way exceeds threshold divide image daughter rects begin know eventually keep subdividing get individual pixels rects zero variance within sort strained logic might convince less variance small rects large ones general trend let me get right propose algorithm listen start considering rectangle covering whole image going pixel pixel calculate variance measure root mean square variation average pixels whole region variance low lower arbitrary limit consider pixels within region equal define region rect color argb representing arithmetic average pixel values variance exceeds arbitrary threshold subdivide image specifically subdivide four generally unequal rects determine subdivide calculate center gravity parent rect pixel lightness darkness multiplied position vector gives moment moment add moments together moments divide number pixels result visual center region divide repeat procedure newly created rectangular regions regions low variance rendered solid color rect regions subdivided algorithm continues reaching individual pixels every region larger pixel successfully encoded rect general technique known quadtree subdivision lends well recursive implementation likely get stack overflow problems four times many rects recursion cycle created potentially rects cycles ten levels deep created million rects better start worrying heap stack demonstration technique seen image left created using fairly insensitive variance threshold meaning subdivision occur unless region rms variance least possible range pixel values subdivision happened infrequently noisiest pixel regions smaller rects tended cluster areas high detail high variation pixel intensities around edges iris eyelashes image right shows rms threshold set lower get detail rects total white outlines around rects omitted right image image left parsed solid rectangles white outlines illustrative purposes using recursive quadtree decomposition described text notice subdivision smaller rectangles tends coincide areas high detail image right parsed rects algorithm tunable couple ways obvious way via variance cutoff parameter variance threshold set low means slightest bit noise given region trigger subdivision region continued operation algorithm however stop subdividing reaching individual pixels another tuning variable minimum tile size image left collage solid filled rectangles rect count image right starting bitmap like feel code produced images consists lines javascript shown another lines java utility routines class called imageutilities see addition need imagemunger java application i described yesterday post yet another lines java first javascript tiles js kas thomas january public domain note work need imagemunger java app ly ubp also need imageutilities class described blog recursive subdivision function quadrecurse rect isdivisible rect push rect return var newrects quaddivide rect partition rect var i i newrects length i size check newrects i newrects i pushrect return var i i newrects length i recurse new rect quadrecurse newrects i function quaddivide rect var pixarray getpixarrayfromrect rect get visual center gravity image var cg packages imageutilities getcg pixarray rect cg cg cg cg cg cg cg cg var centerx cg rect xffff centerx rect var centery cg rect xffff centery rect var widthtocenterx centerx rect var heighttocentery centery rect var rect rect rect widthtocenterx heighttocentery ul var rect rect centery widthtocenterx rect heighttocentery var rect rect widthtocenterx rect rect widthtocenterx heighttocentery ur var rect rect widthtocenterx centery rect widthtocenterx rect heighttocentery lr return rect rect rect rect divisibility function isdivisible rect rect width threshold rect height threshold return false var pixarray getpixarrayfromrect rect var rms packages imageutilities getrmserror pixarray rms rmserror threshold return false return true function getpixarrayfromrect rect var sub image getsubimage rect rect rect rect return sub getrgb rect rect null rect render function render var gd image creategraphics var r null var sub null var pixels null var color null var i i length i r i r continue r r continue r pixels getpixarrayfromrectr color packages imageutilities getaverageawtcolor pixels gd setpaint color gd fillrect r r r r fill solid outlines true gd setcolor java color white gd drawrect r r r r panel updatepanel write svg function writesvg preamble destfile var r null var pixels null var null var color null var output xml version encoding utf standalone doctype svg public wc dtd svg en org tr rec svg dtd svg dtd svg xmlns org svg 'xmlns xlink org xlink 'viewbox 'xml space preserve 'width px 'height px output transform scale var i r null i length i r i pixels getpixarrayfromrectr packages imageutilities getaverageawtcolor pixels color awtcolortohex output outputsvgrect mainarray i color output output svg write output file packages imageutilities savestringtofileoutput destfile function inttohex num num hexstr `` num tostring hexstr length hexstr hexstr substring return hexstr function awtcolortohex var theint getred getgreen getblue return inttohex theint function outputsvgrect r color var str rect str r str r str width r str height r str fill color str stroke color str r return str main work routine usage doquadding svg test svg writes output svg file doquadding preview null renders image jframe function doquadding rms sizelowlimit mode dest image null java lang system println nothing source image return image getwidth image getheight mainrect mainarray new array rmserror threshold rms width threshold height threshold sizelowlimit quadrecurse mainarray mainrect recurse java lang system println total rects mainarray length mode tolowercase indexof preview java lang system println rendering render mainarray mode tolowercase indexof svg java lang system println writing writesvg temp svgstub txt dest mainarray java lang system println done outlines false var start new date actually call entry point begin processing doquadding preview null doquadding svg temp test svg var end new date java lang system println finished end start milliseconds use file give name like tiles js run imagemunger java app i described yesterday post command line passing name image want modify name script file java imagemunger myimage jpg tiles js entry point script doquadding call rd argument svg want write output scalable vector graphics file otherwise pass rd arg preview imagemunger simply render transformed image jframe script makes reference number utility routines written java utility routines class called else imageutilities follows routines fairly self explanatory import java io bufferedreader import java io file import java io fileoutputstream import java io filereader import java io ioexception import java io outputstream imageutilities java kas thomas january see ly ubp subsequent posts public class imageutilities public static void savestringtofile string content string outpath outputstream null try new fileoutputstreamoutpath writecontent getbytes catch ioexception system println could save outpath printstacktrace finally try null close catch ioexception printstacktrace get visual center gravity pixel array pass array raster width public static double getcgint pix double intensity red green blue double cg double averageintensity pvalue i i pix length i pvalue pix i red pvalue green pvalue blue pvalue intensity doublered blue green averageintensity intensity cg intensity i cg intensity i cg averageintensity cg averageintensity cg cg pix length return cg public static double getrmserror pix double accumulator double diff double aveintensity double rms len pix length i i len i aveintensity doublepix i aveintensity len i i len i diff doublepix i aveintensity accumulator diff diff rms accumulator len return math sqrtrms public static java color getaverageawtcolor input ave getaveragecolor input red ave green ave blue ave return new java colorred green blue public static getaveragecolor input red green blue pvalue averagered averagegreen averageblue len input length i i len i pvalue input i red pvalue green pvalue blue pvalue averagered red averagegreen green averageblue blue averagered len averagegreen len averageblue len return averagered averagegreen averageblue public static double getintensity pvalue red pvalue green pvalue blue pvalue double intensity red blue green return intensity public static double getintensity java color intvalue getred intvalue getgreen intvalue getblue return getintensity intvalue public static java color getawtcolor pvalue red pvalue green pvalue blue pvalue return new java colorred green blue public static double getrmse pix pix double rms double accum double intensity double intensity double tmp pix length pix length system println arrays size return rms i i pix length i intensity getintensity pix i intensity getintensity pix i tmp intensity intensity tmp tmp accum tmp rms accum pix length mean squares return math sqrt rms root mean square even though main routine javascript overall processing runs quickly algorithm executes near linear time output around rectangles per second screen disk i included projects future write gradient filled rects instead solid filled rects choosing gradient endpoint colors way minimize differences output original image given two svg images ensemble rects preferably equal number write transformation routine morphs one image via transformations individual rects colors store second image simply ensemble transformations rects first image provides reference rectangles transformed write public key image encryption routine based foregoing notion image becomes key someone use encrypt image private key image unlocking instead writing svg image ensemble individual rects write one rect repeatedly resized repositioned via successive affine transformations encrypt image using technique rewrite one rect many times transformation concert matrix hashing write svg image encryption routine whose difficulty decryption depends non commutative nature matrix multiplication numerical instability inverted matrices write chunky jpeg routine essentially uses quadtree decomposition chunk image prior discrete cosine transformation instead using canonical jpeg chunking insert idea